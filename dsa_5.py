# -*- coding: utf-8 -*-
"""DSA_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a1rni0J1xZ-Nq2k7kDX4pffaHozv665j

Convert 1D Array Into 2D Array

You are given a **0-indexed** 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with Â m rows and n columns using **all** the elements from original.

The elements from indices 0 to n - 1 (**inclusive**) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (**inclusive**) should form the second row of the constructed 2D array, and so on.

Return *an* m x n *2D array constructed according to the above procedure, or an empty 2D array if it is impossible*.
"""

class Solution:
    def construct2DArray(self, original, m, n):
        ans = []
        if len(original) == m*n:
            for i in range(0, len(original), n):
                ans.append(original[i:i+n])
        return ans
s1= Solution()
s1.construct2DArray([1,2,3,4],2,2)



"""You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase **may be** incomplete.

Given the integer n, return *the number of **complete rows** of the staircase you will build*.
"""

class Solution:
    def arrangeCoins(self, n):
        # Initialize pointers to first and last possible row lengths
        left, right = 1, n

        while left <= right:
            # Compute the midpoint between left and right
            mid = left + (right - left) // 2

            # Compute the total number of coins needed for mid complete rows
            coins = (mid * (mid + 1)) // 2

            # If we have enough coins, look for a smaller number of rows
            if coins <= n:
                left = mid + 1
            # Otherwise, look for a larger number of rows
            else:
                right = mid - 1

        # Return the number of complete rows (i.e., right pointer)
        return right

s1= Solution()
s1.arrangeCoins(5)

"""Given an integer array nums sorted in **non-decreasing** order, return *an array of **the squares of each number** sorted in non-decreasing order*.

**Example 1:**

**Input:** nums = [-4,-1,0,3,10]

**Output:** [0,1,9,16,100]
"""

class Solution:
    def sortedSquares(self, A):
        return_array = [0] * len(A)
        write_pointer = len(A) - 1
        left_read_pointer = 0
        right_read_pointer = len(A) - 1
        left_square = A[left_read_pointer] ** 2
        right_square = A[right_read_pointer] ** 2
        while write_pointer >= 0:
            if left_square > right_square:
                return_array[write_pointer] = left_square
                left_read_pointer += 1
                left_square = A[left_read_pointer] ** 2
            else:
                return_array[write_pointer] = right_square
                right_read_pointer -= 1
                right_square = A[right_read_pointer] ** 2
            write_pointer -= 1
        return return_array

s1= Solution()
s1.sortedSquares( [-4,-1,0,3,10])



"""Given two **0-indexed** integer arrays nums1 and nums2, return *a list* answer *of size* 2 *where:*

- answer[0] *is a list of all **distinct** integers in* nums1 *which are **not** present in* nums2*.*
- answer[1] *is a list of all **distinct** integers in* nums2 *which are **not** present in* nums1.

**Note** that the integers in the lists may be returned in **any** order.

**Example 1:**

**Input:** nums1 = [1,2,3], nums2 = [2,4,6]

**Output:** [[1,3],[4,6]]
"""

class Solution:
    def findDifference(self, nums1, nums2):
        n1=set(nums1)
        n2=set(nums2)
        r1=list(set(x for x in nums1 if x not in n2))
        r2=list(set(x for x in nums2 if x not in n1))

        return [r1,r2]

s1=Solution()
s1.findDifference([1,2,3],[2,4,6])



"""Given two integer arrays arr1 and arr2, and the integer d, *return the distance value between the two arrays*.

The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.

**Example 1:**

**Input:** arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2

**Output:** 2
"""

def findTheDistanceValue(a, b, d):
        b.sort()
        counter = 0
        for i in a :
            m =  0
            n = len(b)
            flag = 0
            while m < n :
                mid = (m + n) // 2
                if i < b[mid] : n = mid
                if i > b[mid] : m = mid + 1
                if i == b[mid] :
                    flag = 1
                    break
            if flag == 1 : continue
            if m == n :
                if m == 0 and abs(i - b[m]) > d : counter += 1
                elif m == len(b) and abs(i - b[m-1]) > d : counter += 1
                elif abs(b[m-1] - i) > d and abs(b[m] - i) > d : counter += 1
        return counter

findTheDistanceValue([4,5,8],[10,9,1,8],2)



"""Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears **once** or **twice**, return *an array of all the integers that appears **twice***.

You must write an algorithm that runs in O(n) time and uses only constant extra space.

**Example 1:**

**Input:** nums = [4,3,2,7,8,2,3,1]

**Output:**

[2,3]
"""

class Solution:
    def findDuplicates(self, nums):
        result = []

        for i in range(len(nums)):
            index = abs(nums[i])-1
            if nums[index] < 0:
                result.append(index+1)
            else:
                nums[index] = -nums[index]

        return result

s1=Solution()
s1.findDuplicates([4,3,2,7,8,2,3,1])



"""Suppose an array of length n sorted in ascending order is **rotated** between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:

- [4,5,6,7,0,1,2] if it was rotated 4 times.
- [0,1,2,4,5,6,7] if it was rotated 7 times.

Notice that **rotating** an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Given the sorted rotated array nums of **unique** elements, return *the minimum element of this array*.

You must write an algorithm that runs in O(log n) time.

**Example 1:**

**Input:** nums = [3,4,5,1,2]

**Output:** 1

**Explanation:**

The original array was [1,2,3,4,5] rotated 3 times.
"""

class Solution():
    def findMin(self, nums):
        left = 0
        right = len(nums) - 1

        while left < right:
            mid = left + (right - left) / 2

            if nums[mid] > nums[right]:
                left = mid + 1
            else:
                right = mid

        return nums[left]

s1= Solution()
s1.findMin([3,4,5,1,2])

