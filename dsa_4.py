# -*- coding: utf-8 -*-
"""DSA_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19QDGYksAf9-BCPbK1ntdkxmCOYvJ3h2M
"""



"""<aside>
ðŸ’¡ Given three integer arrays arr1, arr2 and arr3 **sorted** in **strictly increasing** order, return a sorted array of **only** the integers that appeared in **all** three arrays.

**Example 1:**

Input: arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8]

Output: [1,5]

</aside>
"""

# Python function to print common elements in three sorted arrays
def findCommon(ar1, ar2, ar3, n1, n2, n3):

	# Initialize starting indexes for ar1[], ar2[] and ar3[]
	i, j, k = 0, 0, 0

	# Iterate through three arrays while all arrays have elements
	while (i < n1 and j < n2 and k < n3):

		# If x = y and y = z, print any of them and move ahead
		# in all arrays
		if (ar1[i] == ar2[j] and ar2[j] == ar3[k]):
			print(ar1[i])
			i += 1
			j += 1
			k += 1

		# x < y
		elif ar1[i] < ar2[j]:
			i += 1

		# y < z
		elif ar2[j] < ar3[k]:
			j += 1

		# We reach here when x > y and z < y, i.e., z is smallest
		else:
			k += 1


# Driver program to check above function
ar1 = [1,2,3,4,5]
ar2 = [1,2,5,7,9]
ar3 = [1,3,4,5,8]
n1 = len(ar1)
n2 = len(ar2)
n3 = len(ar3)
print("Common elements are  ")
findCommon(ar1, ar2, ar3, n1, n2, n3)



"""Given two **0-indexed** integer arrays nums1 and nums2, return *a list* answer *of size* 2 *where:*

- answer[0] *is a list of all **distinct** integers in* nums1 *which are **not** present in* nums2*.*
- answer[1] *is a list of all **distinct** integers in* nums2 *which are **not** present in* nums1.

**Note** that the integers in the lists may be returned in **any** order.

**Example 1:**

**Input:** nums1 = [1,2,3], nums2 = [2,4,6]

**Output:** [[1,3],[4,6]]

**Explanation:**

For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].

For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].
"""

class Solution:
    def findDifference(self, nums1, nums2):
        n1=set(nums1)
        n2=set(nums2)
        r1=list(set(x for x in nums1 if x not in n2))
        r2=list(set(x for x in nums2 if x not in n1))
        return [r1,r2]

s1= Solution()
s1.findDifference([1,2,3],[2,4,6])



"""<aside>
ðŸ’¡ Given a 2D integer array matrix, return *the **transpose** of* matrix.

The **transpose** of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

**Example 1:**

Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]

Output: [[1,4,7],[2,5,8],[3,6,9]]

</aside>
"""

class Solution:
    def transpose(self, matrix):
        m,n=len(matrix),len(matrix[0])
        ans = [[None] * m for _ in range(n)]
        for i in range(m):
            for j in range(n):
                ans[j][i]=matrix[i][j]
        
        return ans

s1 = Solution()
s1.transpose( [[1,2,3],[4,5,6],[7,8,9]])



"""<aside>
ðŸ’¡ Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is **maximized**. Return *the maximized sum*.

**Example 1:**

Input: nums = [1,4,3,2]

Output: 4

</aside>
"""

class Solution(object):
    def arrayPairSum(self, nums):
        nums.sort()
        result = 0
        numsLen = len(nums)
        for i in range(0, numsLen - 1, 2):
            result += nums[i]
        return result

s1 = Solution()
s1.arrayPairSum([1,4,3,2])



"""<aside>
ðŸ’¡ You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase **may be** incomplete.

Given the integer n, return *the number of **complete rows** of the staircase you will build*.

</aside>
"""

class Solution:
    def arrangeCoins(self, n):
        # Initialize pointers to first and last possible row lengths
        left, right = 1, n
        
        while left <= right:
            # Compute the midpoint between left and right
            mid = left + (right - left) // 2
            
            # Compute the total number of coins needed for mid complete rows
            coins = (mid * (mid + 1)) // 2
            
            # If we have enough coins, look for a smaller number of rows
            if coins <= n:
                left = mid + 1
            # Otherwise, look for a larger number of rows
            else:
                right = mid - 1

        # Return the number of complete rows (i.e., right pointer)
        return right

s1= Solution()
s1.arrangeCoins(5)



"""<aside>
ðŸ’¡ Given an integer array nums sorted in **non-decreasing** order, return *an array of **the squares of each number** sorted in non-decreasing order*.

**Example 1:**

Input: nums = [-4,-1,0,3,10]

Output: [0,1,9,16,100]

</aside>
"""

def sortedSquares(A):
    for i in range(len(A)):
          A[i] *= A[i]
    A.sort()
    return A

sortedSquares([-4,-1,0,3,10])



"""<aside>
ðŸ’¡ You are given an m x n matrix M initialized with all 0's and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 <= x < ai and 0 <= y < bi.

Count and return *the number of maximum integers in the matrix after performing all the operations*

</aside>

"""

class Solution:
    def maxCount(self, m, n, ops):
        length = len(ops)
        if length == 0:
            return m*n
        result = [ops[0][0] , ops[0][1]]
        for i in range(1,length):
            result[0] = min(result[0] , ops[i][0])
            result[1] = min(result[1] , ops[i][1])
        return result[0]*result[1]      

s1 = Solution()
s1.maxCount(3,3,[[2,2],[3,3]])



"""Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].

*Return the array in the form* [x1,y1,x2,y2,...,xn,yn].

**Example 1:**

**Input:** nums = [2,5,1,3,4,7], n = 3

**Output:** [2,3,5,4,1,7]
"""

class Solution:
    def shuffle(self, nums, n):
        arr1=[]
        arr2=[]
        arr3=[]
        for i in range(n):
            arr1.append(nums[i])
        for i in range(n,2*n):
            arr2.append(nums[i])
        for i in range(n):
            arr3.append(arr1[i])
            arr3.append(arr2[i])
        return arr3

s1 = Solution()
s1.shuffle([2,5,1,3,4,7],3)

